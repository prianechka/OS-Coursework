\section{Аналитический раздел}

\subsection{Постановка задачи}
В соответствии с заданием на курсовую работу по дисциплине <<Операционные системы>> требуется разработать ПО, позволяющее изменять яркость экрана с помощью USB-мыши.

Для выполнения задания требуется решить следующие задачи:
\begin{enumerate}
	\item Провести анализ существующих подходов к изменению функциональности внешних устройств в Linux.
	\item Провести анализ существующих способов изменения яркости экрана.
	\item Разработать алгоритмы, необходимые для реализации ПО.
	\item Разработать ПО, предоставляющая требуемую функциональность.
	\item Провести исследование разработанного ПО.
\end{enumerate}

Одновременное нажатие SHIFT-R на клавиатуре и правой кнопки мыши на клавиатуре должно увеличивать яркость экрана, а SHIFT-R и левой кнопки мыши -- уменьшать.
Функциональность мыши должна сохраниться: с её помощью можно перемещать курсор и нажимать правую и левую кнопки мыши.

Для разработки и тестирования данной работы используется мышь Logitech M190 \cite{mouse} и операционная система Ubuntu \cite{ubuntu}.

\subsection{Драйвер устройства}
Драйверы устройств являются одной из разновидностей модулей ядра.
Драйверы полностью скрывают детали, касающиеся работы устройства и предоставляют четкий программный интерфейс для работы с аппаратурой. 
В Unix каждое аппаратное устройство представлено файлом устройства в каталоге /dev. 

\subsubsection{Анализ возможных типов драйвера}
В Unix/Linux драйверы бывают трех типов:
\begin{itemize}
	\item встроенные -- выполнение этих драйверов инициализируется при запуске системы;
	\item драйверы, код которых поделен между ядром и специальной утилиты;
	\item драйверы, реализованные как загружаемые модули ядра.
\end{itemize}

Среди последних выделяют HID-драйверы. 
Класс HID является одним из наиболее часто используемых классов USB. 
Класс HID состоит в основном из устройств, предназначенных для интерактивного взаимодействия с компьютером. 

Для изменения функциональности мыши требуется разработать именно HID-драйвер.

\subsubsection{Алгоритм регистрации USB-драйвера в системе}
Для выполнения задания требуется разработать драйвер мыши. Регистрация USB-драйвера подразумевает \cite{usb_drivers}:
\begin{enumerate}
	\item Заполнение структуры \textit{usb\_driver}.
	\item Регистрация структуры в системе.
\end{enumerate}

Сначала требуется инициализировать поля структуры \textit{usb\_driver}. 

Структура usb\_driver состоит из следующих полей \cite{usb_driver}:
\begin{itemize}
	\item \textbf{name} -- имя драйвера, должно быть уникальным среди USB-драйверов.
	\item \textbf{id\_table} -- массив структур \textit{usb\_device\_id}, который содержит список всех типов USB-устройств, которые обслуживает драйвер.
	\item \textbf{probe} -- функция обратного вызова, является точкой входа драйвера. Она будет вызвана только для тех устройств, которые соответствуют параметрам, перечисленным в структуре \textit{usb\_device\_id}.
	\item \textbf{disconnect} -- функция обратного вызова, которая вызывается при отключении устройства от драйвера.
\end{itemize}

В функции \textbf{probe} для каждого подключаемого устройства выделяется структура в памяти, заполняется, затем регистрируется, например, символьное устройство, и проводится регистрация устройства в \textit{sysfs}.

При установке собственного драйвера сначала необходимо выгрузить модуль \textit{usbhid}, который автоматически регистрирует все стандартные драйверы в системе.
Данный модуль устанавливает стандартный драйвер мыши и не позволяет установить свой.

\subsection{Подсистема ввода/вывода}
Подсистема ввода/вывода выполняет запросы файловой подсистемы и подсистемы управления процессами для доступа к периферийным устройствам (дискам, магнитным лентам, терминалам и т.д.). 
Она обеспечивает необходимую буферизацию данных и взаимодействует с драйверами устройств — специальными модулями ядра, непосредственно обслуживающими внешние устройства.

Для использования подсистемы ввода/вывода требуется инициализировать структуру \textit{input\_dev} \cite{input_dev}. 
Поле evbit этой структуры отвечает за то, какие события могут происходить на устройстве.
Для мыши возможны два вида событий: \textit{EV\_KEY} \cite{EV_KEY} -- нажатия кнопок мыши, и \textit{EV\_REL} -- изменения относительного положения курсора на экране.

Для вызова событий, связанных с клавишами используется системный вызов \textit{input\_report\_key} \cite{input_report_key}, который принимает устройство ввода, кнопку, на которую вызывается событие, и дополнительная информация о событии.

\subsection{URB}
Сообщение, передаваемое от драйвера USB-устройства системе, называется USB Request Block или URB \cite{ldd}. 
Оно описывается структурой \textit{struct urb}.
URB используется для передачи или приёма информации от конечной точки на заданное USB-устройство в асинхронном режиме \cite{urb}.
Каждая конечная точка может обрабатывать очередь из URB, следовательно, на одну конечную точку может быть выслать множество URB.
URB создаются динамически и содержат внутренний счётчик ссылок, что позволяет автоматически освобождать память, когда блок запроса больше никем не используется \cite{ldd}.

Структура \textit{struct urb} не может быть создана статически в драйвере или внутри другой структуры \cite{urb}. 
Для её создания нужно воспользоваться системным вызовом \textit{usb\_alloc\_urb}. 
Для завершения работы драйвера с URB, драйвер должен вызвать функцию \textit{usb\_free\_urb}.

Чтобы правильно инициализировать URB перед отправкой на конечную точку при прерывании используется системный вызов \textit{ usb\_fill\_int\_urb} \cite{int}. 

Как только URB был должным образом создан и инициализирован драйвером, он готов к отправке. 

Для отправки используется системный вызов \textit{usb\_submit\_urb} \cite{submit}.

\subsection{Анализ способов изменения функциональности внешних устройств}
Прерывание – сигнал к процессору, испускаемый аппаратными средствами или программным обеспечением, и указывающий на событие, которое
требует немедленного внимания.  
Процессор отвечает, приостанавливая свои текущие действия, сохраняя свое состояние и выполняя функцию, называемую обработчиком прерываний, для обработки события.

В ОС Linux различают быстрые и медленные прерывания. 
Обработка быстрых прерываний выполняется от начала до конца. 
В современных системах осталось только одно быстрое прерывание -- от таймера. 

Чтобы сократить время выполнения обработчиков прерываний обработчики медленных аппаратных прерываний делятся на две части, которые называются верхняя (top) и нижняя (bottom) половины (half).
Выполнение нижних половин инициируется верхними половинами.

В современных ОС Linux имеется три типа нижних половин:
\begin{enumerate}
	\item Softirq -- отложенные прерывания.
	\item Tasklet -- тасклеты.
	\item Workqueue -- очереди работ.
\end{enumerate}

Так как требуется обрабатывать события от мыши и клавиатуры, нужно определиться с тем, какой механизм использовать.

\subsubsection{Очереди работ}
Очередь работ является еще одной концепцией для обработки отложенных функций. 
Функции рабочих очередей выполняются в контексте процесса ядра. 
Это означает, что функции очереди задач не должны быть атомарными, как функции тасклета \cite{work}. 

Очередь работ будет использоваться для обработки событий, связанных с мышью. 
Это связано с тем, что в обработчике прерывания будет происходить изменение яркости экрана, поэтому процесс может перейти в состояние ожидания.

\subsection{Анализ подходов к изменению яркости экрана}
Большинство ноутбуков предоставляют способ изменения яркости экрана с помощью горячих клавиш.
Но для реализации изменения яркости с помощью мыши этот способ не работает.
Поэтому разработчиками Ubuntu предусмотрен другой метод.

Максимально возможное значение яркости экрана содержится в файле \textit{/sys/class/backlight/intel\_backlight/max\_brightness}.
Текущее же значение яркости экрана содержится в файле \textit{/sys/class/backlight/intel\_backlight/brightness}.
Для изменения текущей яркости экрана достаточно изменить значение, хранящееся в файле.

Для чтения и записи в файл нового значения яркости используется статический буфер. 
Для буфера определен размер - \textit{MAX\_BRINGHTNESS\_CLASS}, равный 6.
Поскольку буфер используется для чтения и записи числа, количество элементов выбрано таким образом, чтобы в буфер можно было записать значения в диапазоне от 0 до 10000.

\newpage
\subsection{Выводы}
В результате проведенного анализа было решено:
\begin{itemize}
	\item для выполнения задания разработать HID-драйвер, который должен быть реализован как загружаемый модуль ядра;
	\item для изменения функциональности USB-мыши использовать очереди работ;
	\item для изменения яркости экрана требуется изменить значение, хранящееся в файле \textit{/sys/class/backlight/intel\_backlight/brightness};
\end{itemize}